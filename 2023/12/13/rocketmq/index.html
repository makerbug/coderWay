<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"makerbug.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="RocketMQ架构角色：  Producer：消息的生产者，Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。 Consumer：Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer">
<meta property="og:type" content="article">
<meta property="og:title" content="rocketmq">
<meta property="og:url" content="https://makerbug.github.io/2023/12/13/rocketmq/index.html">
<meta property="og:site_name" content="这是liuluc&#39;s个人博客">
<meta property="og:description" content="RocketMQ架构角色：  Producer：消息的生产者，Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。 Consumer：Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/TPbhbnerU0.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/SKG6DvkoPi.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/LnXN8GdZ7k.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/NqEOFFIg9j.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/LochZOrIiI.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/8JJchA5cOU.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/RDtUsU3fg7.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/ZbAkQskxaQ.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/sSlUK1q2vZ.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/K8lsZdfOLT.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/9m4XrjdW9H.jpg">
<meta property="og:image" content="https://makerbug.github.io/rocketmq/GiTjpZG3VG.jpg">
<meta property="article:published_time" content="2023-12-13T05:09:05.000Z">
<meta property="article:modified_time" content="2023-12-20T08:34:33.266Z">
<meta property="article:author" content="liuluc">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://makerbug.github.io/rocketmq/TPbhbnerU0.jpg">


<link rel="canonical" href="https://makerbug.github.io/2023/12/13/rocketmq/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://makerbug.github.io/2023/12/13/rocketmq/","path":"2023/12/13/rocketmq/","title":"rocketmq"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>rocketmq | 这是liuluc's个人博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">这是liuluc's个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">一名程序员、足球运动员、摄影师、音乐家、骑行者的成长之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">RocketMQ架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">消费者分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PushConsumer"><span class="nav-number">2.1.</span> <span class="nav-text">PushConsumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SimpleConsumer"><span class="nav-number">2.2.</span> <span class="nav-text">SimpleConsumer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">消息过滤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">4.</span> <span class="nav-text">消费者负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%B2%92%E5%BA%A6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">4.1.</span> <span class="nav-text">消息粒度负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E8%B4%9F%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.1.</span> <span class="nav-text">顺序消息负载机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">消费进度管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BD%8D%E7%82%B9"><span class="nav-number">5.1.</span> <span class="nav-text">消息位点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-number">5.2.</span> <span class="nav-text">消费位点初始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9"><span class="nav-number">5.3.</span> <span class="nav-text">重置消费位点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="nav-number">6.</span> <span class="nav-text">消费重试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.1.</span> <span class="nav-text">触发条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5%E4%B8%BB%E8%A6%81%E8%A1%8C%E4%B8%BA"><span class="nav-number">6.2.</span> <span class="nav-text">消费重试策略主要行为</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%B5%81%E6%8E%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">消息流控机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">8.</span> <span class="nav-text">死信队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB%E4%B8%80%E8%87%B4"><span class="nav-number">9.</span> <span class="nav-text">订阅关系一致</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">如何保证消息消费的顺序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%9C%89%E5%BA%8F%E5%8F%91%E9%80%81"><span class="nav-number">10.1.</span> <span class="nav-text">生产者有序发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%9C%89%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="nav-number">10.2.</span> <span class="nav-text">消费者有序消费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8MessageListenerOrderly%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">10.3.</span> <span class="nav-text">使用MessageListenerOrderly顺序消费有两个问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">RocketMQ如何解决重复消息问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="nav-number">12.</span> <span class="nav-text">RocketMQ如何保证消息不丢失</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">12.1.</span> <span class="nav-text">发送消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E9%98%9F%E5%88%97%E7%B2%92%E5%BA%A6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">13.</span> <span class="nav-text">RocketMQ队列粒度负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E6%B6%88%E6%81%AF%E7%B2%92%E5%BA%A6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">14.</span> <span class="nav-text">RocketMQ消息粒度负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E7%9A%84Rebalance"><span class="nav-number">15.</span> <span class="nav-text">RocketMQ的Rebalance</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liuluc</p>
  <div class="site-description" itemprop="description">热爱每一个傍晚</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://makerbug.github.io/2023/12/13/rocketmq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liuluc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="这是liuluc's个人博客">
      <meta itemprop="description" content="热爱每一个傍晚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="rocketmq | 这是liuluc's个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rocketmq
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-13 13:09:05" itemprop="dateCreated datePublished" datetime="2023-12-13T13:09:05+08:00">2023-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-20 16:34:33" itemprop="dateModified" datetime="2023-12-20T16:34:33+08:00">2023-12-20</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="RocketMQ架构"><a href="#RocketMQ架构" class="headerlink" title="RocketMQ架构"></a>RocketMQ架构</h2><p>角色：</p>
<ol>
<li>Producer：消息的生产者，Producer与NameServer集群中的其中一个节点（<strong>随机选择</strong>）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的<strong>Master</strong>建立长连接，且定时向Master发送心跳。</li>
<li>Consumer：Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的<strong>Master、Slave</strong>建立长连接，且定时向<strong>Master、Slave</strong>发送心跳</li>
<li>Broker: 暂存和传输消息，Topic就是存放在Broker中的，可搭建主从架构，一个Master和多个Slave。</li>
<li>NameServer： 管理Broker,Broker的元数据都要注册给NameServer。</li>
<li>Topic</li>
<li>Message Queue：一个Topic默认四个Message Queue</li>
</ol>
<h2 id="消费者分类"><a href="#消费者分类" class="headerlink" title="消费者分类"></a>消费者分类</h2><p>RocketMQ面向不同的业务场景提供了不同类型的消费者，支持PushConsumer、SimpleConsumer、PullConsumer三种类型的消费者</p>
<h3 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h3><p>消费者初始化时注册一个消费监听器，并在消费监听器内部实现消息处理逻辑。由RocketMQ的SDK在后台完成消息获取，触发监听器调用以及进行消息重试处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 消费示例：使用PushConsumer消费普通消息。</span><br><span class="line">ClientServiceProvider provider = ClientServiceProvider.loadService();</span><br><span class="line">String topic = &quot;YourTopic&quot;;</span><br><span class="line">FilterExpression filterExpression = new FilterExpression(&quot;YourFilterTag&quot;, FilterExpressionType.TAG);</span><br><span class="line">PushConsumer pushConsumer = provider.newPushConsumerBuilder()</span><br><span class="line">    // 设置消费者分组。</span><br><span class="line">    .setConsumerGroup(&quot;YourConsumerGroup&quot;)</span><br><span class="line">    // 设置接入点。</span><br><span class="line">    .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(&quot;YourEndpoint&quot;).build())</span><br><span class="line">    // 设置预绑定的订阅关系。</span><br><span class="line">    .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))</span><br><span class="line">    // 设置消费监听器。</span><br><span class="line">    .setMessageListener(new MessageListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public ConsumeResult consume(MessageView messageView) &#123;</span><br><span class="line">            // 消费消息并返回处理结果。</span><br><span class="line">            return ConsumeResult.SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();                </span><br></pre></td></tr></table></figure>
<p>pushConsumer消费消息时，若消息处理逻辑出现预期之外的阻塞导致消息处理一直无法执行成功，SDK会按照消费超时处理，强制提交消费失败结果，并按照消费重试逻辑进行处理。 </p>
<blockquote>
<p>出现消费超时情况时，SDK虽然提交消费失败结果，但是当前消费线程可能仍然无法响应中断，还会继续处理消息。</p>
</blockquote>
<p><img src="/./rocketmq/TPbhbnerU0.jpg"><br>在PushConsumer类型中，消息的实时处理能力是基于SDK内部的典型Reactor线程模型实现的。<strong>SDK内置了一个长轮询线程</strong>，先将消息异步拉取到SDK内置的缓存队列中，再分别提交到消费线程中，触发监听器执行本地消费逻辑。</p>
<p>使用PushConsumer消费者消费时，不允许使用以下方式处理消息，否则RocketMQ无法保证消息的可靠性。</p>
<ol>
<li>消息还未处理完成，就提前返回消费成功结果，如果消费失败，RocketMQ无感知，不会进行重试。</li>
<li>在消费监听器内将消息再次分发到自定义的其他线程，消费监听器异步返回结果，同1</li>
</ol>
<h3 id="SimpleConsumer"><a href="#SimpleConsumer" class="headerlink" title="SimpleConsumer"></a>SimpleConsumer</h3><p>SimpleConsumer是一种接口原子型的消费者类型，消息的获取、消费状态提交以及消费重试都是通过消费者业务逻辑主动发起调用完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 消费示例：使用 SimpleConsumer 消费普通消息，主动获取消息处理并提交。 </span><br><span class="line">ClientServiceProvider provider = ClientServiceProvider.loadService();</span><br><span class="line">String topic = &quot;YourTopic&quot;;</span><br><span class="line">FilterExpression filterExpression = new FilterExpression(&quot;YourFilterTag&quot;, FilterExpressionType.TAG);</span><br><span class="line">SimpleConsumer simpleConsumer = provider.newSimpleConsumerBuilder()</span><br><span class="line">        // 设置消费者分组。</span><br><span class="line">        .setConsumerGroup(&quot;YourConsumerGroup&quot;)</span><br><span class="line">        // 设置接入点。</span><br><span class="line">        .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(&quot;YourEndpoint&quot;).build())</span><br><span class="line">        // 设置预绑定的订阅关系。</span><br><span class="line">        .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))</span><br><span class="line">        // 设置从服务端接受消息的最大等待时间</span><br><span class="line">        .setAwaitDuration(Duration.ofSeconds(1))</span><br><span class="line">        .build();</span><br><span class="line">try &#123;</span><br><span class="line">    // SimpleConsumer 需要主动获取消息，并处理。</span><br><span class="line">    List&lt;MessageView&gt; messageViewList = simpleConsumer.receive(10, Duration.ofSeconds(30));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        // 消费处理完成后，需要主动调用 ACK 提交消费结果。</span><br><span class="line">        try &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; catch (ClientException e) &#123;</span><br><span class="line">            logger.error(&quot;Failed to ack message, messageId=&#123;&#125;&quot;, messageView.getMessageId(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; catch (ClientException e) &#123;</span><br><span class="line">    // 如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span><br><span class="line">    logger.error(&quot;Failed to receive message&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<ol>
<li>自定义消费速率：SimpleConsumer由业务逻辑主动调接口获取消息，因此可以自由调整获取消息的频率，自定义控制消费速率。</li>
<li>需要异步化、批量消费等高级定制场景</li>
</ol>
<h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>消费者订阅了某个主题后，RocketMQ会将该主题中所有消息都投递给消费者。若消费者只需要关注部分消息，可通过设置过滤条件在<strong>RocketMQ服务端进行过滤</strong>，只获取到需要关注的消息子集，避免收到大量无效的消息。</p>
<p>两种方式：</p>
<ol>
<li>Tag标签过滤：消息的Tag标签</li>
<li>SQL属性过滤：消息的属性，包括用户自定义属性和系统属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//发送消息，设置Tag标签</span><br><span class="line">Message message = messageBuilder.setTopic(&quot;topic&quot;)</span><br><span class="line">//设置消息索引键，可根据关键字精确查找某条消息。</span><br><span class="line">.setKeys(&quot;messageKey&quot;)</span><br><span class="line">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span><br><span class="line">//该示例表示消息的Tag设置为&quot;TagA&quot;。</span><br><span class="line">.setTag(&quot;TagA&quot;)</span><br><span class="line">//消息体。</span><br><span class="line">.setBody(&quot;messageBody&quot;.getBytes())</span><br><span class="line">.build();</span><br><span class="line"></span><br><span class="line">//订阅消息，匹配单个标签</span><br><span class="line">String topic = &quot;Your Topic&quot;;</span><br><span class="line">//只订阅消息标签为&quot;TagA&quot;的消息。</span><br><span class="line">FilterExpression filterExpression = new FilterExpression(&quot;TagA&quot;, FilterExpressionType.TAG);</span><br><span class="line">pushConsumer.subscribe(topic, filterExpression);</span><br><span class="line"></span><br><span class="line">//订阅消息，匹配多个标签</span><br><span class="line">String topic = &quot;Your Topic&quot;;</span><br><span class="line">//只订阅消息标签为&quot;TagA&quot;的消息。</span><br><span class="line">FilterExpression filterExpression = new FilterExpression(&quot;TagA&quot;, FilterExpressionType.TAG);</span><br><span class="line">pushConsumer.subscribe(topic, filterExpression);</span><br><span class="line"></span><br><span class="line">//订阅消息，匹配Topic中所有消息，不进行过滤</span><br><span class="line">String topic = &quot;Your Topic&quot;;</span><br><span class="line">//使用Tag标签过滤消息，订阅所有消息。</span><br><span class="line">FilterExpression filterExpression = new FilterExpression(&quot;*&quot;, FilterExpressionType.TAG);</span><br><span class="line">pushConsumer.subscribe(topic, filterExpression);</span><br></pre></td></tr></table></figure>


<h2 id="消费者负载均衡"><a href="#消费者负载均衡" class="headerlink" title="消费者负载均衡"></a>消费者负载均衡</h2><p>根据消费者类型的不同，消费者负载均衡策略分为以下两种模式</p>
<ol>
<li>消息粒度负载均衡：PushConsumer和SimpleConsumer</li>
<li>队列粒度负载均衡：PullConsumer默认负载策略</li>
</ol>
<h3 id="消息粒度负载均衡"><a href="#消息粒度负载均衡" class="headerlink" title="消息粒度负载均衡"></a>消息粒度负载均衡</h3><p><img src="/./rocketmq/SKG6DvkoPi.jpg"><br>同一个队列中的消息，可以平均分配给多个消费者共同消费。结果是随机的，并不能指定消息被哪一个特定的消费者处理。</p>
<p>消息粒度的负载均衡机制，是基于<strong>内部的单条消息确认语义</strong>实现的。消费者获取某条消息后，服务端将该消息<strong>加锁</strong>，保证这条消息对其他消费者不可见，直到该消息<strong>消费成功或消费超时</strong>。因此，即使多个消费者同时消费同一队列的消息，<strong>服务端也可保证消息不会被多个消费者重复消费</strong>。</p>
<h4 id="顺序消息负载机制"><a href="#顺序消息负载机制" class="headerlink" title="顺序消息负载机制"></a>顺序消息负载机制</h4><p><img src="/./rocketmq/LnXN8GdZ7k.jpg"><br>如上图所述，队列Queue1中有4条顺序消息，这四条消息属于同一消息组G1。在消费过程中，前面的消息M1、M2被消费者Consumer A1处理时，只要消费状态没有提交，消费者A2是无法并行消费后续的M3、M4消息。</p>
<h2 id="消费进度管理"><a href="#消费进度管理" class="headerlink" title="消费进度管理"></a>消费进度管理</h2><p>RocketMQ的生产者和消费者在进行消息的首发时，必然会涉及以下场景：<strong>消息先生产后订阅或先订阅后生产</strong>。这两种场景下，<br>存在以下问题：</p>
<ol>
<li>消费者客户端启动后从哪里开始消费？</li>
<li>如何标记已消费的消息，确保下次不会再重复处理该消息</li>
<li>消息被消费过一次后，业务出现异常需要故障恢复，该消息能否被重新消费。</li>
</ol>
<p>这些都是由RocketMQ的消费进度管理机制来定义的。<br>RocketMQ通过**消费位点(ConsumerOffset)**管理消费进度</p>
<p>如何定位到一条消息:Topic+Queue+Offset(0-Long.Max)<br>Offset就是消息在队列上的位置</p>
<p><img src="/./rocketmq/NqEOFFIg9j.jpg"></p>
<p>最小消息位点(MinOffset):队列中最早一条消息的位点<br>最大消息位点(MaxOffset):队列中最新一条消息的位点<br>消息队列逻辑上无限存储，但由于服务端物理节点的存储空间有限，RocketMQ会滚动删除队列中存储最早的消息，因此，最小消息位点和最大消息位点会一直递增变化。</p>
<p><img src="/./rocketmq/LochZOrIiI.jpg"></p>
<h3 id="消息位点"><a href="#消息位点" class="headerlink" title="消息位点"></a>消息位点</h3><p>RocketMQ<strong>领域模型</strong>为发布订阅模式，每个主题的队列可以被多个消费者分组订阅，若某条消息被某个消费者消费后直接删除，则其他订阅了该主题的消费者将无法消费该消息。</p>
<p>RocketMQ通过<strong>消费位点</strong>管理消息的消费进度，每条消息被消费者消费完成后不会立即在队列中删除，RocketMQ会基于每个<strong>消费者分组</strong>维护一份消费记录，该记录<strong>指定消费者分组消费某一个队列时，消费过的最新一条消息的位点</strong>，即消费位点。</p>
<p>当消费者客户端离线又重新上线时，会严格按照<strong>服务端保存</strong>的消费进度继续处理消息，<strong>如果服务端保存的历史位点信息已被过期删除，此时消费位点向前移动至服务端存储的最小位点</strong>（不会重复消费么）</p>
<p><img src="/./rocketmq/8JJchA5cOU.jpg"></p>
<h3 id="消费位点初始值"><a href="#消费位点初始值" class="headerlink" title="消费位点初始值"></a>消费位点初始值</h3><p>消费位点初始值指的是消费者分组<strong>首次启动消费者消费消息</strong>时，服务端保存的消费位点的初始值。RocketMQ定义为最大消费位点，即从最新消息开始消费。</p>
<h3 id="重置消费位点"><a href="#重置消费位点" class="headerlink" title="重置消费位点"></a>重置消费位点</h3><p>若消费者分组的初始消费位点或者当前消费位点不符合业务预期，可以通过重置消费位点调整消费进度。</p>
<p>场景：</p>
<ol>
<li>消费历史消息</li>
<li>消费堆积快速清理：跳过一部分堆积不需要的消息</li>
<li>消费回溯：重新消费已被处理的消息</li>
</ol>
<p>方案：</p>
<ol>
<li>重制到队列中的指定位点</li>
<li>重置某一时刻对应的消费位点</li>
</ol>
<h2 id="消费重试"><a href="#消费重试" class="headerlink" title="消费重试"></a>消费重试</h2><p>RocketMQ的消费重试：消费者在消费某条消息失败后，RocketMQ服务端根据重试策略重新消费该消息，超过一定次数后还未消费成功，该消息将不再继续重试，直接被发送到<strong>死信队列</strong>中。<br>主要解决的是业务逻辑处理失败导致的<strong>消费完整性</strong>问题，是一种业务兜底的策略。</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ol>
<li>消费失败：消费者返回消息失败状态标识或抛出非预期异常</li>
<li>消费处理超时，包括在PushConsumer中排队超时</li>
</ol>
<h3 id="消费重试策略主要行为"><a href="#消费重试策略主要行为" class="headerlink" title="消费重试策略主要行为"></a>消费重试策略主要行为</h3><ol>
<li>重试过程状态机：控制消息在重试流程中的状态和变化逻辑</li>
<li>重试间隔: 上一次消费失败或超时后，下次重新尝试消费的间隔时间</li>
<li>最大重试次数：消息可被重试消息的最大次数。</li>
</ol>
<p>PushConsumer消费消息时，消息的几个主要状态如下：<br><img src="/./rocketmq/RDtUsU3fg7.jpg"><br>inflight:处理中状态,消息处于消费中还未返回消费结果的状态<br>DLQ：死信状态，重试已达最大次数，投递至死信队列，可以通过消息死信队列的消息进行消息恢复</p>
<p>PushConsumer的最大重试次数由消费者分组创建时的元数据控制</p>
<p>非顺序消息的重试间隔未阶梯时间<br>顺序消息的重试间隔为固定时间</p>
<h2 id="消息流控机制"><a href="#消息流控机制" class="headerlink" title="消息流控机制"></a>消息流控机制</h2><p>消息流控指的是系统容量或水压过高，RocketMQ服务端会通过快速失败返回流控错误来避免底层承受过高压力</p>
<p>触发条件：</p>
<ol>
<li>存储压力大：消费者分组的初始消费位点为当前队列的最大消费位点。若某些场景例如业务上新等需要回溯到指定时刻前开始消息，此时队列的存储压力会瞬间飙升，触发消息流控。</li>
<li>服务端请求任务排队溢出：若消费者消费能力不足，导致队列中有大量堆积消息，当<strong>堆积消息超过一定数量后会触发消息流控</strong>，减少下游消费系统压力。</li>
</ol>
<p>流控行为：<br>当系统触发消息发送流控时，客户端会收到系统限流错误和异常，错误信息如下：</p>
<ol>
<li>reply-code ： 530</li>
<li>reply-text：TOO_MANY_REQUESTS<br>客户端收到系统流控错误码之后，会根据<strong>指数退避策略</strong>进行消息发送重试。</li>
</ol>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>RocketMQ中消息重试超过重试次数（默认16次）就会放到死信队列中<br>死信消息的特性：</p>
<ol>
<li>不会再被消费者正常消费</li>
<li>有效期与正常消息相同，均为3天，3天后会被自动删除</li>
</ol>
<p>死信队列的特性:</p>
<ol>
<li>一个死信队列对应一个消费者组Group ID， 而不是对应单个消费者实例。</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic</li>
</ol>
<h2 id="订阅关系一致"><a href="#订阅关系一致" class="headerlink" title="订阅关系一致"></a>订阅关系一致</h2><p>订阅关系一致：同一个消费者Group ID下所有Consumer实例所订阅的Topic、Tag必须完全一致。<br>如果订阅关系不一致，消费消息的逻辑就会混乱，甚至导致消息丢失。</p>
<p>正确的订阅<br><img src="/./rocketmq/ZbAkQskxaQ.jpg"><br>错误的订阅<br><img src="/./rocketmq/sSlUK1q2vZ.jpg"></p>
<p>更新订阅信息时，订阅信息是按照<strong>消费组存放</strong>的，这步骤就会导致同一个消费组内的各个消费者客户端的订阅信息相互被覆盖。通过调研 Broker 端的代码，我们发现：相同消费组的订阅信息必须保持一致 , 否则同一个消费组内的各个消费者客户端的订阅信息相互被覆盖，从而<strong>导致某个消费者客户端无法拉取到新的消息</strong>。</p>
<h2 id="如何保证消息消费的顺序性"><a href="#如何保证消息消费的顺序性" class="headerlink" title="如何保证消息消费的顺序性"></a>如何保证消息消费的顺序性</h2><ol>
<li>生产者有序发送</li>
<li>消费存储时保持和发送顺序一致 这个由mq内部保持一致</li>
<li>消费者有序消费</li>
</ol>
<p>要实现严格的顺序消息，简单且可行的办法就是：<br>保证生产者-MQServer-消费者是一对一对一的关系</p>
<h3 id="生产者有序发送"><a href="#生产者有序发送" class="headerlink" title="生产者有序发送"></a>生产者有序发送</h3><p>队列<strong>先进先出</strong>的特性可以保证存入队列的消息顺序和拉取的消息顺序是一致的，因此，只需保证一组相同的消息按照给定的顺序存入<strong>同一个队列中</strong>，就能保证生产者的有序存储。</p>
<p>解决方案：RocketMQ支持生产者在投放消息的时候自定义投放策略。<strong>实现一个MessageQueueSelector接口</strong>，使用<strong>Hash取模法（订单ID%队列数量）</strong>来保证同一个订单在同一个队列中即可</p>
<p>但这种方式在<strong>broker挂掉或新增服务器</strong>时会导致队列数量变化，从而导致个别订单分布到不同队列中，导致不能顺序消费</p>
<h3 id="消费者有序消费"><a href="#消费者有序消费" class="headerlink" title="消费者有序消费"></a>消费者有序消费</h3><p>RocketMQ的MessageListener回调函数提供了两种消费模式，<strong>有序消费模式MessageListenOrderly和并发消费模式MessageListenerConcurrently</strong>。</p>
<blockquote>
<p>实际上，每一个消费者的消费端都是采用线程池实现多线程消费的模式，MessageListenerConcurrently是拉取到新消息后提交到线程池去消费，而MessageListenerOrderly则是通过加<strong>分布式锁和本地所锁</strong>保证同时只有一条线程去消费一个队列上的数据。</p>
</blockquote>
<p>顺序消费模式使用<strong>3把锁</strong>来保证消费的顺序性</p>
<ol>
<li>broker端的分布式锁：该锁保证<strong>同一个consumerGroup下同一个messageQueue只会被分配给一个consumerClient</strong></li>
<li>messageQueue的本地synchronized锁:<strong>该锁保证同一时刻对于同一个队列只有一个线程去消费它</strong>。</li>
<li>processQueue的本地consumerLock：该锁防止消息队列因<strong>发生负载均衡</strong>而被分配给其他客户端，进而导致<strong>两个客户端重复消费</strong>的行为。</li>
</ol>
<h3 id="使用MessageListenerOrderly顺序消费有两个问题"><a href="#使用MessageListenerOrderly顺序消费有两个问题" class="headerlink" title="使用MessageListenerOrderly顺序消费有两个问题"></a>使用MessageListenerOrderly顺序消费有两个问题</h3><ol>
<li>使用了很多的锁，降低了吞吐量</li>
<li>前一个消息阻塞时后面消息都会被阻塞。如果遇到消费失败的消息，会自动对当前消息进行重试（每次间隔时间为1s），无法自动跳过，重试最大次数为Integer.MAX_VALUE，这将导致当前队列消费暂停，因此通常需要<strong>设定一个最大消费次数，以及处理好所有可能的异常情况</strong>。</li>
</ol>
<h2 id="RocketMQ如何解决重复消息问题"><a href="#RocketMQ如何解决重复消息问题" class="headerlink" title="RocketMQ如何解决重复消息问题"></a>RocketMQ如何解决重复消息问题</h2><p>造成消费重复的根本原因是：<strong>网络不可达</strong>。只要通过网络交换数据，就无法避免这个问题<br>如果消费端收到两条一样的消息，应该怎么处理</p>
<ol>
<li><strong>消费端处理消息的业务逻辑保持幂等性</strong></li>
<li>保证每条消息都有<strong>唯一编号</strong>且保证<strong>消息处理成功与去重日志表同时出现</strong></li>
</ol>
<p>Rocket不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重</p>
<h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><p><img src="/./rocketmq/K8lsZdfOLT.jpg"><br>消息的三个阶段</p>
<ol>
<li>Producer发送消息</li>
<li>Broker处理消息</li>
<li>Consumer消费消息</li>
</ol>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>三种方式</p>
<ol>
<li>同步发送：Producer向broker发送消息，<strong>阻塞当前线程</strong>等待broker响应发送结果</li>
<li>异步发送：Producer首先构建一个broker发送消息的任务，把该任务提交给线程池，把该任务提交给线程池，等执行完成后，回调<strong>用户自定义</strong>的回调函数，执行处理结果。</li>
<li>OneWay：发送出去就完事，不处理响应结果<br><strong>默认为同步发送方式</strong></li>
</ol>
<p>手段一：<strong>同步发送方式</strong><br>手段二：发送消息如果失败或超时，则重新发送，发送重试本质其实就是一个for循环，当发送消息发生异常的时候重新循环发送。默认重试3次，重试次数可以通过producer指定<br>手段三：broker提供多master模式，即使某台broker宕机了，保证消息可以投递到另外一台正常的broker上。<br>如果broker只有一个节点，则broker宕机了，即使producer有重试机制，也没用，因此利用多主模式，当某台broker宕机了，换一台broker进行投递。</p>
<h2 id="RocketMQ队列粒度负载均衡"><a href="#RocketMQ队列粒度负载均衡" class="headerlink" title="RocketMQ队列粒度负载均衡"></a>RocketMQ队列粒度负载均衡</h2><p><img src="/./rocketmq/9m4XrjdW9H.jpg"><br>消费者负载均衡：是指为消费者组下的<strong>每个消费者分配订阅主题下的消费队列</strong>，分配了消息队列就可以知道去消费哪个消息队列上的消息。这里指的时集群模式<strong>队列负载均衡</strong>，集群模式下，<strong>一个消息队列同一时间只能分配给组内的一个消费者进行消费</strong></p>
<p>队列粒度的消息负载均衡是在每个消费者端进行的，<strong>并不是由某个节点统一进行负载均衡之后将分配结果通知到每位消费者</strong>。消费者在启动时会向所有的Broker发送心跳包进行注册，通知Broker消费者上线，下线的时候也会向Broker发送取消注册的请求，<strong>Broker会维护消费者的注册信息</strong>，在消费者发生变更时会通知消费者进行负载均衡。<br>Consumer在拉取消息之前需要对TopicMessage进行负载操作，负载操作由一个定时器来完成，定时间隔默认20s</p>
<h2 id="RocketMQ消息粒度负载均衡"><a href="#RocketMQ消息粒度负载均衡" class="headerlink" title="RocketMQ消息粒度负载均衡"></a>RocketMQ消息粒度负载均衡</h2><p><img src="/./rocketmq/GiTjpZG3VG.jpg"><br>消息粒度负载均衡策略中，同一个消费者组内的<strong>多个消费者将按照消息粒度平均分摊主题中的所有消息</strong>，即同一个队列中的消息，可被平均分配给组内多个消费者共同消费。</p>
<p>消息粒度负载均衡策略保证同一个队列的消息可以被组内多个消费者共同处理，<strong>但是该策略使用的消息分配算法结果是随机的，不能指定消息被哪一个特定的消费者处理</strong>。</p>
<blockquote>
<p>当消费者成功获取到某条消息后，服务端会对该消息加锁，保证该消息对其他消费者不可见，知道消息成功或超时，<strong>所以多个消费者同时消费同一个消息队列中的消息，服务端也可以保证消息不会被多个消费者重复消费</strong>。</p>
</blockquote>
<h2 id="RocketMQ的Rebalance"><a href="#RocketMQ的Rebalance" class="headerlink" title="RocketMQ的Rebalance"></a>RocketMQ的Rebalance</h2><p>同一时刻同一个Queue只能被一个Consumer持有，但同一个Consumer可以同时消费多个队列<br>日常使用时，Consumer的上下线，Queue的动态扩容，都可能破坏分配均衡性，故而Rocket提供了一套完整的Rebalance</p>
<p>Rebalance触发的条件：</p>
<ol>
<li>Consumer启动之时执行Start方法主动执行负载均衡逻辑。</li>
<li>定时任务触发。 消费者本身也会定时执行负载均衡，默认是20s执行一次；</li>
<li>Broker下发通知告知Client需要负载均衡：Broker发现消费者组变更（消费者组新增消费者，消费者组订阅信息发生了变化），<strong>会向消费者组下的所有消费者发送变更请求，通知组下的每个消费者进行负载均衡</strong></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/12/Nio/" rel="prev" title="Nio">
                  <i class="fa fa-angle-left"></i> Nio
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/14/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="next" title="云原生">
                  云原生 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">liuluc</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">NaNm</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">NaN:aN</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
